% function [dcell, Ffr, kernel] = run_deconvolution2(Ff, Fneu, kernel)
load('D:\CODE\MariusBox\SpikeDetection\kernel.mat')

% the basis functions should depend on timescale of sensor and imaging rate
ops.imageRate = getOr(ops, {'imageRate'}, 10);
ops.sensorTau = getOr(ops, {'sensorTau'}, 2); % approximate timescale in seconds
ops.sameKernel = getOr(ops, {'sameKernel'}, 1); % 1 for same kernel per plane, 0 for individual kernels (not recommended)
mtau = ops.image_rate * ops.sensor_tau; 

isroi = [stat.mrs]./[stat.mrs0]<1.2 & [stat.npix]>20 & [stat.npix]<200;
Ff = Fcell{1}(isroi, :);
Fneu = FcellNeu{1}(isroi, :);

f0 = (mtau/2);

Ff   = Ff';
Fneu = -Fneu';

sd = std(Ff - my_conv2(Ff, 2, 1), [], 1);
Ff = 2 * Ff ./ repmat(1e-5 + sd, size(Ff,1), 1);
Fneu = 2 * Fneu ./ repmat(1e-5 + sd, size(Ff,1), 1);

Params = [1 3 3 3000]; %type of deconvolution, Th, Thi(nner loop), maxiter

kernel = interp1(1:numel(kernel), kernel, ...
    linspace(1, numel(kernel), ceil(f0/3 * numel(kernel))));
kernel = normc(kernel');

npad = 250;
[NT, NN] = size(Ff);
F1 = cat(1, zeros(npad,NN), double(Ff), zeros(npad,NN));
F1 = bsxfun(@minus, F1 , median(F1,1));

nt0 = numel(kernel);

taus = mtau * [1/4 1/2 1 2 4];
Nbasis = numel(taus);
kerns = zeros(nt0, Nbasis);
for i = 1:Nbasis
    kerns(:,i) = exp(-[1:nt0]/taus(i));
end
%%

dcell = cell(NN,1);
kernelS = repmat(kernel, 1, NN);

for iter = 1:10
    parfor icell = 1:size(Ff,2)
        [kernelS(:, icell), F1(:,icell)] =...
            single_step_single_cell(Ff(:,icell), F1(:, icell), Fneu(:,icell), Params, ...
            kernelS(:,icell), kerns, NT, npad);
    end
    if ops.sameKernel
        kernelS = repmat(median(kernelS,2), 1, NN);
    end
end
Ffr = zeros(size(Ff));
parfor icell = 1:size(Ff,2)
    [~, ~, dcell{icell}, Ffr(:, icell)] = single_step_single_cell(Ff(:,icell), F1(:, icell), Fneu(:,icell), Params, ...
        kernelS(:,icell), kerns, NT, npad);
end



Ffr = 1/2 * Ffr .* repmat(1e-5 + sd, size(Ff,1), 1);
%%

